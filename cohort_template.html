<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interest Cluster Contact Exchange</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Define the primary color palette based on a bright blue */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap');
        :root {
            --primary-blue: #3b82f6; /* Tailwind blue-500 */
            --light-blue: #eff6ff; /* Tailwind blue-50 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-blue);
            color: #1f2937; /* Dark text for high contrast */
        }
        .card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px rgba(59, 130, 246, 0.15);
        }
        /* Style for highlighted referral card */
        .card-highlight {
            border: 2px solid #f59e0b; /* Amber/Yellow border */
            transform: scale(1.02);
            box-shadow: 0 10px 25px rgba(245, 158, 11, 0.3);
        }
        .join-btn {
            background-color: var(--primary-blue);
            transition: background-color 0.2s ease;
        }
        .join-btn:hover {
            background-color: #2563eb; /* Tailwind blue-600 */
        }
        .full-btn {
            background-color: #6b7280; /* Tailwind gray-500 */
            cursor: not-allowed;
            opacity: 0.8;
        }
        .login-prompt-btn {
            background-color: #f59e0b; /* Tailwind amber-500 */
            transition: background-color 0.2s ease;
        }
        .login-prompt-btn:hover {
             background-color: #d97706; /* Tailwind amber-600 */
        }
        /* Ensure the clamp works for card descriptions */
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;  
            overflow: hidden;
        }
        /* Download VCF Button (Now uses Indigo for emphasis) */
        .download-btn {
            background-color: #4f46e5; /* Tailwind indigo-600 */
            transition: background-color 0.2s ease;
        }
        .download-btn:hover {
            background-color: #4338ca; /* Tailwind indigo-700 */
        }
        
        /* --- NEW STYLES FOR REDUCED BUTTONS AND STATS --- */
        .member-actions-full {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        .connection-stats-text {
            /* Maximize space for the text */
            flex-grow: 1;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            font-weight: 600; /* semi-bold */
            color: #1f2937; /* text-gray-800 */
        }
        .action-icon-btn {
            /* Icon-only button styles */
            width: 40px; /* Fixed size */
            height: 40px;
            padding: 0;
            border-radius: 9999px; /* Fully rounded */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevents text from shrinking the button */
            transition: background-color 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .share-btn-icon { background-color: #f59e0b; color: white; }
        .share-btn-icon:hover { background-color: #d97706; }
        .stats-btn-icon { background-color: #3b82f6; color: white; }
        .stats-btn-icon:hover { background-color: #2563eb; }
        
        /* New style for downloaded state button */
        .downloaded-btn {
            background-color: #9ca3af; /* Tailwind gray-400 */
            cursor: not-allowed;
            color: #ffffff;
            font-weight: 600;
        }
        
        /* --- NEW STYLES FOR ANIMATIONS (GOAL 1) --- */

        /* Blinking/Scaling Animation for Primary Action Button */
        @keyframes pulse-once {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.95; }
        }

        .animate-download-attention {
            animation: pulse-once 1.5s infinite ease-in-out;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5); /* Blue glow */
        }

        /* Arrow Animation inside the button */
        @keyframes bounce-down {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-4px);
            }
            60% {
                transform: translateY(-2px);
            }
        }

        .animate-arrow-bounce {
            display: inline-block;
            animation: bounce-down 2s infinite;
        }
        
        /* --- END NEW STYLES FOR ANIMATIONS --- */
        
        /* Styling for the popularity tags in the stats modal */
        .popularity-tag {
            padding: 2px 6px;
            border-radius: 9999px; /* Full rounded corners */
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 8px;
        }
        .pop-most { background-color: #d1fae5; color: #065f46; } /* Green */
        .pop-avg { background-color: #fef3c7; color: #b45309; } /* Amber */
        .pop-less { background-color: #fee2e2; color: #991b1b; } /* Red */
    </style>
</head>
<body class="min-h-screen pb-4">

    <div id="notificationArea" class="fixed top-4 right-4 z-50 w-full max-w-xs space-y-2">
        </div>

    <header class="bg-white shadow-lg sticky top-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <h1 class="text-2xl font-bold text-blue-600">NEAR Network</h1>
                <nav>
                    </nav>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8">
        <h2 class="text-4xl font-extrabold text-gray-900 mb-4 text-center">
            Find Your Cohort
        </h2>
        <p class="text-center text-lg text-gray-500 mb-10 max-w-3xl mx-auto">
            Join a cluster and connect mutually with 5 others who share your interests. Your contact details will only be exchanged once the cohort is full.
        </p>
        
        <div id="clusterGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
            <div id="loadingClusters" class="col-span-full text-center py-12 text-gray-500">
                <i data-lucide="loader" class="w-8 h-8 mx-auto animate-spin text-blue-500"></i>
                <p class="mt-3 text-lg font-medium">Loading Interest Clusters...</p>
            </div>
            </div>
    </main>
    
    <div id="inputModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 space-y-6">
            <h3 class="text-2xl font-bold text-gray-800 border-b pb-3">Final Step: Define Your VCF Display</h3>
            
            <form id="contactForm">
                <input type="hidden" id="modalClusterId">
                
                <p class="text-sm text-gray-500 mb-4">
                    Your profile data (Nickname, Profession, WhatsApp) will be fetched from the **`user_profiles`** table by the server. Please confirm how your name should appear in the shared contact file:
                </p>

                <div class="flex items-start p-4 border rounded-lg bg-blue-50">
                    <div class="flex items-center h-5">
                        <input id="displayProfession" type="checkbox" checked class="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded">
                    </div>
                    <div class="ml-3 text-sm">
                        <label for="displayProfession" class="font-bold text-gray-800">Display my Profession</label>
                        <p class="text-gray-600 mt-1">
                            <span class="font-semibold">Checked:</span> Name will be **[Nickname (Profession)]**.<br>
                            <span class="font-semibold">Unchecked:</span> Name will be **[Nickname NEARR]** (Note the space).
                        </p>
                    </div>
                </div>

                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" onclick="closeModal('inputModal')" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200">
                        Cancel
                    </button>
                    <button type="submit" class="join-btn px-4 py-2 text-sm font-medium text-white rounded-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                        Confirm Join Cluster
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="statsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="p-6 border-b flex justify-between items-center">
                <h3 class="text-2xl font-bold text-gray-800" id="statsModalTitle">Cluster Statistics: Loading...</h3>
                <button type="button" onclick="closeModal('statsModal')" class="text-gray-400 hover:text-gray-600">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <div class="p-6 overflow-y-auto flex-grow">
                <div id="statsModalContent" class="space-y-8">
                    
                    <div id="statsSummary" class="bg-gray-50 p-4 rounded-xl shadow-inner">
                        <h4 class="font-bold text-lg mb-4 text-blue-600">Demographic Overview</h4>
                        <div id="statsPlaceholder" class="text-gray-500 text-center py-4">
                            Loading statistical data...
                        </div>
                        
                        <div id="statsGrid" class="grid grid-cols-1 sm:grid-cols-2 gap-x-8 gap-y-4 text-sm hidden">
                            <div class="space-y-2">
                                <p><span class="font-semibold text-gray-700">Age Range:</span> <span id="stat_age">N/A</span></p>
                                <p><span class="font-semibold text-gray-700">Gender Breakdown:</span></p>
                                <ul id="stat_gender" class="ml-4 list-disc text-gray-600">
                                    </ul>
                                <p><span class="font-semibold text-gray-700">Geographic Mix:</span></p>
                                <ul id="stat_country" class="ml-4 list-disc text-gray-600">
                                    </ul>
                            </div>
                            
                            <div>
                                <p class="font-semibold text-gray-700 mb-2">Profession Mix (Top 5):</p>
                                <ul id="stat_profession" class="space-y-1">
                                    </ul>
                            </div>
                        </div>
                        
                    </div>
                    
                    <div>
                        <h4 class="font-bold text-lg mb-2 text-gray-800">Current Members (<span id="memberCount">0</span>/<span id="maxCount">5</span>)</h4>
                        <div class="overflow-x-auto rounded-xl border border-gray-200">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nickname</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Gender</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Age</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Country</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Looking For</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Available For</th>
                                    </tr>
                                </thead>
                                <tbody id="memberTableBody" class="bg-white divide-y divide-gray-200">
                                    </tbody>
                            </table>
                        </div>
                        <p id="memberLoading" class="text-center text-sm text-gray-500 mt-4">Loading member list...</p>
                    </div>
                </div>
            </div>
            
            <div class="p-4 border-t flex justify-end">
                <button type="button" onclick="closeModal('statsModal')" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200">
                    Close
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // --- 1. CONFIGURATION AND DATA ---

        // Global variables provided by the environment (required for Supabase integration)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // These keys are expected to be injected by the hosting environment
        const supabaseUrl = '__SUPABASE_URL_INJECTION__';
        const supabaseAnonKey = '__SUPABASE_ANON_KEY_INJECTION__';

        let supabase; // Global instance for the client
        let userId = null;
        let userReferralCode = null;
        let isAuthReady = false; // Tracks if the initial Supabase session check is complete

        // Viewer's Country - Set to a placeholder. It will be determined dynamically upon successful authentication.
        let userCountry = "Loading Country..."; 
        
        // ** DYNAMIC CLUSTER DATA **
        // Global array to hold clusters fetched from Supabase
        let dynamicClusters = []; 
        
        // The Fixed Capacity Cohort Size (Used as a fallback default if max_members is not available)
        const MAX_COHORT_SIZE = 5;
        
        // ** STATE TRACKING **
        // Tracks user's membership status for quick access: { cluster_id: { ..., user_is_member: true } }
        let userClusterMemberships = {}; 
        // Tracks the overall cohort status: { cluster_id: { cohort_id: 'C_1_2', is_full: false, current_members: 3, vcf_uploaded: false, vcf_file_name: null, vcf_download_count: 0, max_members: 5, user_has_downloaded: false } }
        let clusterStatusCache = {}; 
        
        // ** REFERRAL STATE TRACKING **
        let highlightedClusterId = null; // Cluster ID from referral link, used for UI highlight


        /**
         * Fetches all clusters from the dynamic_clusters Supabase table.
         * Populates the global dynamicClusters array.
         * This function should only fetch the static definitions (Name, Details, Max Members).
         * Dynamic status is fetched by fetchAndRenderClusters.
         */
        async function fetchClustersFromSupabase() {
            try {
                if (!supabase) throw new Error("Supabase client is not initialized.");
                
                // Fetch necessary fields from dynamic_clusters
                const { data, error } = await supabase
                    .from('dynamic_clusters')
                    .select('id, name, details, max_members, referral_message_template')
                    .order('id', { ascending: true }); 

                if (error) {
                    console.error('Supabase Error fetching dynamic clusters:', error);
                    showNotification(`Error loading clusters: ${error.message}`, 'error');
                    dynamicClusters = []; 
                } else {
                    dynamicClusters = data;
                    console.log(`Successfully loaded ${dynamicClusters.length} clusters from Supabase.`);
                }

            } catch (err) {
                console.error('Fatal Error in fetchClustersFromSupabase:', err);
                dynamicClusters = []; 
                showNotification('Fatal error during initial cluster fetch.', 'error');
            }
        }


        /**
         * Fetches the customized message template from the already loaded dynamicClusters array.
         * @param {number} clusterId - The ID of the cluster.
         * @returns {Promise<string>} - The message template containing the {{referral_link}} placeholder.
         */
        async function fetchClusterReferralMessage(clusterId) {
            try {
                const cluster = dynamicClusters.find(c => c.id === clusterId);
                
                if (!cluster) {
                     console.warn(`Cluster ID ${clusterId} not found in loaded data.`);
                     return "Join this unique interest cohort I'm in on NEAR Network! Get your unique link here: {{referral_link}}";
                }
                
                let rawTemplate = cluster.referral_message_template || "Join this unique interest cohort I'm in on NEAR Network! Get your unique link here: {{referral_link}}";
                const clusterName = cluster.name || 'a unique interest';
                
                if (rawTemplate.includes('[Cluster Name]')) {
                    rawTemplate = rawTemplate.replace('[Cluster Name]', clusterName);
                }
                
                return rawTemplate;

            } catch (err) {
                console.error('Fatal Error in fetchClusterReferralMessage:', err);
                return "Hey, check out this great cluster on NEAR Network! Get your unique link here: {{referral_link}}";
            }
        }
        
        // --- 2. UI MANIPULATION AND HELPERS ---

        function redirectToLogin() {
            sessionStorage.setItem('intended_destination', window.location.pathname + window.location.search);
            console.log(`Saved intended destination to: ${sessionStorage.getItem('intended_destination')}`);

            showNotification("You must be logged in to join or download contacts. Redirecting to login...", 'info');
            
            setTimeout(() => {
                window.location.href = '/login.html';
            }, 1500);
        }

        function showNotification(message, type) {
            const area = document.getElementById('notificationArea');
            const colorMap = {
                'success': { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-400' },
                'error': { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-400' },
                'info': { bg: 'bg-blue-100', text: 'text-blue-800', border: 'border-blue-400' },
            };
            const colors = colorMap[type] || colorMap['info'];

            const notification = document.createElement('div');
            notification.className = `${colors.bg} ${colors.text} p-4 rounded-lg border-l-4 ${colors.border} shadow-lg transition-opacity duration-300`;
            notification.textContent = message;

            area.prepend(notification);
            
            if (type === 'error') {
                console.error(`UI Notification (Error): ${message}`);
            } else if (type === 'info') {
                 console.warn(`UI Notification (Info): ${message}`);
            } else {
                 console.log(`UI Notification (Success): ${message}`);
            }

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.addEventListener('transitionend', () => notification.remove());
            }, 5000);
        }

        function openModal(modalId, clusterId = null) {
            if (!userId) {
                redirectToLogin();
                return;
            }
            if (clusterId && document.getElementById('modalClusterId')) {
                document.getElementById('modalClusterId').value = clusterId;
            }
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
            }
        }
        
        function showModal(clusterId) {
             openModal('inputModal', clusterId);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('flex');
                modal.classList.add('hidden');
                if (modalId === 'inputModal') {
                    document.getElementById('contactForm').reset();
                }
            }
        }
        
        async function generateShareLink(clusterId) {
            if (!userId) {
                redirectToLogin();
                return;
            }
            
            if (!userReferralCode) {
                 showNotification("Cannot share: Your referral code is not available yet.", 'error');
                 return;
            }

            showNotification('Generating customized share link...', 'info');

            try {
                let messageTemplate = await fetchClusterReferralMessage(clusterId);
                const baseUrl = window.location.origin;
                const shareUrl = `${baseUrl}${window.location.pathname}?cluster_id=${clusterId}&ref_code=${userReferralCode}`;
                const finalShareText = messageTemplate.replace('{{referral_link}}', shareUrl);
                
                const tempInput = document.createElement('textarea');
                tempInput.value = finalShareText;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                
                showNotification('Customized share message and link copied to clipboard!', 'success');
                console.log(`Generated and copied text:\n\n${finalShareText}`);

            } catch (err) {
                console.error('Failed to generate or copy share text: ', err);
                showNotification('Failed to copy link. Please check console.', 'error');
            }
        }

        // --- 3. STATISTICAL UTILITY FUNCTIONS (Client-side aggregation) ---

        function calculateGenderDistribution(members) {
            const total = members.length;
            if (total === 0) return { male_pct: 0, female_pct: 0, other_pct: 0 };

            let maleCount = 0;
            let femaleCount = 0;
            
            members.forEach(member => {
                const gender = member.gender ? String(member.gender).toLowerCase() : '';
                if (gender === 'male') {
                    maleCount++;
                } else if (gender === 'female') {
                    femaleCount++;
                }
            });

            const male_pct = ((maleCount / total) * 100).toFixed(0);
            const female_pct = ((femaleCount / total) * 100).toFixed(0);
            const otherCount = total - maleCount - femaleCount;
            const other_pct = ((otherCount / total) * 100).toFixed(0);

            return { male_pct, female_pct, other_pct };
        }

        function calculateAgeRange(members) {
            if (members.length === 0) return 'N/A';

            const ages = members
                .map(m => parseInt(m.age, 10))
                .filter(age => !isNaN(age) && age > 0);

            if (ages.length === 0) return 'N/A';

            const minAge = Math.min(...ages);
            const maxAge = Math.max(...ages);

            if (minAge === maxAge) return `${minAge} years old`;
            return `${minAge} - ${maxAge} years`;
        }

        function calculateProfessionMix(members) {
            const total = members.length;
            if (total === 0) return [];

            const professionCounts = {};
            members.forEach(member => {
                const profession = member.profession ? String(member.profession).trim() : 'Unspecified';
                professionCounts[profession] = (professionCounts[profession] || 0) + 1;
            });

            const professionList = Object.entries(professionCounts).map(([name, count]) => ({
                name: name,
                count: count,
                pct: ((count / total) * 100).toFixed(0) 
            }));

            return professionList
                .sort((a, b) => b.count - a.count)
                .slice(0, 5);
        }

        function processAndRenderStats(stats, cohortMembers) {
            const memberCount = cohortMembers.length;
            const ageSpan = document.getElementById('stat_age');
            const genderList = document.getElementById('stat_gender');
            const countryList = document.getElementById('stat_country');
            const professionList = document.getElementById('stat_profession');
            const statsGrid = document.getElementById('statsGrid');
            
            genderList.innerHTML = '';
            countryList.innerHTML = '';
            professionList.innerHTML = '';
            
            ageSpan.textContent = calculateAgeRange(cohortMembers);
            
            const genderDistribution = calculateGenderDistribution(cohortMembers);
            
            if (genderDistribution.male_pct > 0) {
                genderList.insertAdjacentHTML('beforeend', `<li>Male: ${genderDistribution.male_pct}%</li>`);
            }
            if (genderDistribution.female_pct > 0) {
                genderList.insertAdjacentHTML('beforeend', `<li>Female: ${genderDistribution.female_pct}%</li>`);
            }
            if (genderDistribution.other_pct > 0) {
                genderList.insertAdjacentHTML('beforeend', `<li>Other / N/A: ${genderDistribution.other_pct}%</li>`);
            }
            if (memberCount === 0 || (genderDistribution.male_pct === 0 && genderDistribution.female_pct === 0 && genderDistribution.other_pct === 0)) {
                genderList.insertAdjacentHTML('beforeend', `<li>No gender data available.</li>`);
            }

            let viewerCountryCount = 0;
            cohortMembers.forEach(member => {
                const country = member.country ? String(member.country).trim() : '';
                if (country.toLowerCase() === userCountry.toLowerCase()) {
                    viewerCountryCount++;
                }
            });
            let totalOthersCount = memberCount - viewerCountryCount; 
            
            const viewerCountryPct = memberCount > 0 ? ((viewerCountryCount / memberCount) * 100).toFixed(0) : 0;
            const abroadPct = memberCount > 0 ? ((totalOthersCount / memberCount) * 100).toFixed(0) : 0;

            countryList.insertAdjacentHTML('beforeend', `<li>${userCountry}: ${viewerCountryPct}%</li>`);
            countryList.insertAdjacentHTML('beforeend', `<li>Abroad: ${abroadPct}%</li>`);

            const topProfessions = calculateProfessionMix(cohortMembers);
            
            if (topProfessions.length > 0) {
                topProfessions.forEach((p, index) => {
                    let popClass = '';
                    let popularityText = '';
                    if (index < 2) { 
                        popClass = 'pop-most';
                        popularityText = 'Top Mix';
                    } else if (index === 2) {
                         popClass = 'pop-avg';
                         popularityText = 'Mid Mix';
                    } else {
                        popClass = 'pop-less';
                        popularityText = 'Lower Mix';
                    }
                    
                    const li = `
                        <li class="flex items-center">
                            <span class="text-gray-900 font-medium">${p.name} (${p.pct}%)</span>
                            <span class="popularity-tag ${popClass}">${popularityText}</span>
                        </li>
                    `;
                    professionList.insertAdjacentHTML('beforeend', li);
                });
            } else {
                 professionList.insertAdjacentHTML('beforeend', `<li class="text-gray-500">No profession data available.</li>`);
            }

            document.getElementById('statsPlaceholder').classList.add('hidden');
            statsGrid.classList.remove('hidden');
        }

        async function viewClusterStats(clusterId, clusterName) {
            if (!userId) {
                redirectToLogin();
                return;
            }
            
            const cluster = dynamicClusters.find(c => c.id === clusterId);
            const clusterMaxMembers = cluster?.max_members || MAX_COHORT_SIZE; 

            document.getElementById('statsModalTitle').textContent = `Cluster Statistics: ${clusterName}`;
            document.getElementById('statsPlaceholder').classList.remove('hidden');
            document.getElementById('statsGrid').classList.add('hidden');
            document.getElementById('memberTableBody').innerHTML = '';
            document.getElementById('memberLoading').textContent = 'Loading member list...';
            document.getElementById('memberLoading').classList.remove('hidden');
            document.getElementById('memberCount').textContent = '...';
            document.getElementById('maxCount').textContent = clusterMaxMembers; 
            
            openModal('statsModal');
            
            try {
                const response = await fetch(`/api/cluster-stats?cluster_id=${clusterId}&user_id=${userId}&user_country=${userCountry}`, {
                    method: 'GET',
                });
                
                const result = await response.json();

                if (!response.ok || !result.success) {
                     const errorMsg = result.message || "Failed to fetch cluster statistics.";
                     document.getElementById('statsPlaceholder').textContent = `Error: ${errorMsg}`;
                     document.getElementById('memberLoading').textContent = 'Error loading members.';
                     throw new Error(errorMsg);
                }

                const { cohort_members, cluster_stats } = result;

                const currentMemberCount = cohort_members.length;
                processAndRenderStats(cluster_stats, cohort_members); 
                
                const tableBody = document.getElementById('memberTableBody');
                tableBody.innerHTML = ''; 
                
                document.getElementById('memberCount').textContent = currentMemberCount;

                if (currentMemberCount === 0) {
                     document.getElementById('memberLoading').textContent = 'No other members have joined yet.';
                     document.getElementById('memberLoading').classList.remove('hidden');
                } else {
                    cohort_members.forEach(member => {
                        const lookingFor = (member.friend_reasons && Array.isArray(member.friend_reasons) ? member.friend_reasons.join(', ') : member.friend_reasons) || 'N/A';
                        const availableFor = (member.services && Array.isArray(member.services) ? member.services.join(', ') : member.services) || 'N/A';

                        const row = `
                            <tr class="hover:bg-gray-50">
                                <td class="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${member.nickname}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${member.gender || 'N/A'}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${member.age || 'N/A'}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${member.country || 'N/A'}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${lookingFor}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${availableFor}</td>
                            </tr>
                        `;
                        tableBody.insertAdjacentHTML('beforeend', row);
                    });
                    document.getElementById('memberLoading').classList.add('hidden');
                }

            } catch (error) {
                console.error('Error fetching cluster stats:', error);
                showNotification(`Could not load statistics for ${clusterName}.`, 'error');
            }
        }


        /**
         * Renders the cluster cards based on the current state.
         * (Refactored to rely on caches populated by fetchAndRenderClusters)
         */
        function renderClusters() {
            try {
                console.log("Rendering cluster cards...");
                
                const grid = document.getElementById('clusterGrid');
                const loadingElement = document.getElementById('loadingClusters');

                if (!grid) {
                     console.error("CRITICAL: 'clusterGrid' element not found!");
                     showNotification("Fatal Error: Cannot find the card display area.", 'error');
                     return; 
                }

                grid.innerHTML = ''; 

                if (loadingElement) {
                     loadingElement.classList.add('hidden'); 
                }

                dynamicClusters.forEach(category => {
                    const clusterId = category.id;
                    const clusterName = category.name; 
                    const maxMembers = category.max_members || MAX_COHORT_SIZE; 
                    
                    const state = clusterStatusCache[clusterId] || { 
                        cohort_id: `Cluster_${clusterId}`, 
                        is_full: false, 
                        current_members: 0,
                        vcf_uploaded: false, 
                        vcf_file_name: null, 
                        vcf_download_count: 0, 
                        max_members: maxMembers, 
                        user_has_downloaded: false, 
                    };
                    
                    const userIsMember = userClusterMemberships[clusterId]?.user_is_member; 
                    const remaining = state.max_members - state.current_members;
                    
                    // Button Logic Flags (User Requirement 4)
                    const isDownloadReady = state.vcf_uploaded && state.vcf_file_name;
                    const userHasDownloaded = state.user_has_downloaded;
                    
                    // Dynamic Text Calculations
                    const downloadCount = state.vcf_download_count;
                    const connectionsMadeByOthers = downloadCount > 0 ? downloadCount - 1 : 0; 
                    const leftToConnect = state.max_members - downloadCount; 
                    
                    let connectionStatsText = '';
                    
                    if (userIsMember) {
                        if (isDownloadReady && !userHasDownloaded) {
                            // Download available (vcf_uploaded: true, user_has_downloaded: false)
                            connectionStatsText = `${state.max_members} people are waiting to connect with you, download the vcf now!`;
                        } else if (userHasDownloaded) {
                            // Download complete (vcf_uploaded: true, user_has_downloaded: true)
                            connectionStatsText = `You have made ${connectionsMadeByOthers} connections, ${leftToConnect} people remaining to connect with you.`;
                        } else if (state.is_full && !isDownloadReady) {
                            // Full but processing (vcf_uploaded: false, user_is_member: true, is_full: true)
                            connectionStatsText = `VCF generation is underway...`;
                        } else {
                            // Filling up (vcf_uploaded: false, user_is_member: true, is_full: false)
                            connectionStatsText = `Waiting for ${remaining} more members to fill the cluster.`;
                        }
                    } else if (state.is_full) {
                        // Not a member, full
                        connectionStatsText = `Cluster is full. Connections: ${downloadCount}/${state.max_members}`;
                    } else {
                        // Not a member, open
                        connectionStatsText = `${state.current_members}/${state.max_members} spots taken. Join now!`;
                    }
                    

                    // Shared Icon Actions HTML
                    const sharedIconActions = `
                        <button class="action-icon-btn stats-btn-icon" title="View Stats" onclick="viewClusterStats(${clusterId}, '${clusterName}')">
                            <i data-lucide="bar-chart-3" class="w-4 h-4"></i>
                        </button>
                        <button class="action-icon-btn share-btn-icon" title="Share Link" onclick="generateShareLink(${clusterId})">
                            <i data-lucide="share-2" class="w-4 h-4"></i>
                        </button>
                    `;
                    
                    let primaryButtonHTML = '';
                    let mainContentHTML = ''; 
                    let statusTextColor = 'text-gray-700';
                    let cardClass = 'card bg-white rounded-xl p-5 space-y-3'; // Base card class
                    
                    if (highlightedClusterId === clusterId) {
                        cardClass += ' card-highlight';
                    }
                    
                    // --- Primary Button Logic (User Requirement 4) ---
                    if (!isAuthReady) {
                        primaryButtonHTML = `<button class="bg-gray-400 cursor-not-allowed w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>Loading...</button>`;
                    } else if (!userId) {
                        // Guest User
                        primaryButtonHTML = `<button class="login-prompt-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" onclick="redirectToLogin()">Log in to Join</button>`;
                    } else if (userIsMember) {
                        // Authenticated Member
                        
                        if (userHasDownloaded) {
                            // User has downloaded (vcf_uploaded: true, user_has_downloaded: true)
                            primaryButtonHTML = `<button class="downloaded-btn w-full font-semibold py-2 rounded-lg shadow-md" disabled>(${downloadCount}/${state.max_members}) Download Complete</button>`;
                            
                        } else if (isDownloadReady) {
                            // Download available (vcf_uploaded: true, user_has_downloaded: false)
                            const fileNameToUse = state.vcf_file_name || state.cohort_id;
                            statusTextColor = 'text-indigo-700 font-bold';
                            
                            primaryButtonHTML = `<button 
                                class="download-btn w-full text-white font-semibold py-2 rounded-lg shadow-xl animate-download-attention" 
                                id="downloadBtn_${clusterId}" 
                                onclick="downloadContacts('${fileNameToUse}', ${clusterId})">
                                <span class="flex items-center justify-center gap-2">
                                    <i data-lucide="arrow-down-to-line" class="w-5 h-5 animate-arrow-bounce"></i>
                                    Download Contacts
                                </span>
                            </button>`;
                            
                        } else if (state.is_full) {
                            // Full but processing (vcf_uploaded: false, is_full: true)
                            primaryButtonHTML = `<button class="full-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>VCF Processing...</button>`;
                            statusTextColor = 'text-gray-500';

                        } else {
                            // Filling up (vcf_uploaded: false, is_full: false)
                            primaryButtonHTML = `<button class="full-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>In Progress (${remaining} spots left)</button>`;
                            statusTextColor = 'text-gray-500';
                        }
                        
                        // Layout: Actions Left, Stats Right (Applies only to members)
                        mainContentHTML = `
                            <div class="flex items-center justify-between w-full mt-3" id="clusterActions_${clusterId}">
                                <div class="flex gap-2">
                                    ${sharedIconActions}
                                </div>
                                <p class="connection-stats-text text-right ${statusTextColor}">
                                    ${connectionStatsText}
                                </p>
                            </div>
                        `;

                    } else if (state.is_full) {
                        // Authenticated Non-member: Cohort Full (vcf_uploaded: doesn't matter, can't join)
                        primaryButtonHTML = `<button class="full-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>Cluster Full (Wait for next)</button>`;
                    } else {
                        // Authenticated Non-member: Cohort Open (vcf_uploaded: false)
                        primaryButtonHTML = `<button class="join-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" onclick="showModal(${clusterId})">Join Cluster</button>`;
                    }
                    
                    
                    // Final Card Assembly
                    const cardHTML = `
                        <div id="clusterCard_${clusterId}" class="${cardClass}" data-cluster-id="${clusterId}">
                            <h3 class="text-xl font-semibold text-blue-600">${category.name}</h3>
                            <div class="text-xs font-medium text-gray-500 mb-2">
                                ${state.current_members}/${state.max_members} Members
                            </div>
                            <p class="text-gray-500 text-sm h-16 line-clamp-3">
                                ${category.details}
                            </p>
                            ${primaryButtonHTML}
                            ${mainContentHTML}
                        </div>
                    `;
                    grid.insertAdjacentHTML('beforeend', cardHTML);
                });
                
                // Initialize Lucide icons after rendering cards
                lucide.createIcons();
                
                console.log("renderClusters finished.");

            } catch (error) {
                console.error("CRITICAL RENDER FAILURE:", error);
                showNotification(`Fatal rendering error: ${error.message}. Check console for details.`, 'error');
            }
        }
        
        // --- 4. CORE LOGIC (Node.js API Call Assumptions) ---
        
        // ** REFACTOR: Replaced checkAllClusterStatuses with fetchAndRenderClusters **
        /**
         * Fetches all cluster data and the user's current status for all of them
         * in a single API call, then updates caches and renders the dashboard.
         * Implements User Requirements 1 & 2.
         */
        async function fetchAndRenderClusters() {
            if (!isAuthReady) {
                console.warn("Authentication not ready. Cannot fetch clusters.");
                return;
            }

            // Ensure loading indicator is visible while fetching
            const loadingElement = document.getElementById('loadingClusters');
            if (loadingElement) loadingElement.classList.remove('hidden');

            showNotification('Fetching cluster data and membership status...', 'info');

            try {
                let url = `/api/clusters`;
                
                // Conditionally add user_id (Requirement 2)
                if (userId) {
                    url += `?user_id=${userId}`;
                    
                    // Add referral code if present and user is logged in
                    const refCode = sessionStorage.getItem('referral_ref_code');
                    if (refCode) {
                        url += `&ref_code=${refCode}`;
                    }
                }
                
                // Exponential backoff logic for resilience
                const MAX_RETRIES = 3;
                let result;
                let response;
                
                for (let i = 0; i < MAX_RETRIES; i++) {
                    try {
                        response = await fetch(url, { method: 'GET' });
                        result = await response.json();
                        if (!response.ok || !result.success || !result.data) {
                            throw new Error(result.message || 'Server returned an invalid response structure.');
                        }
                        break; // Success, exit retry loop
                    } catch (error) {
                        if (i === MAX_RETRIES - 1) throw error; // Throw on final failure
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                    }
                }
                
                const clusterData = result.data;
                
                // Reset caches based on new data
                userClusterMemberships = {};
                clusterStatusCache = {};

                clusterData.forEach(cluster => {
                    const clusterId = cluster.id;
                    
                    // Update global dynamic clusters with latest status info (current_members, cohort_id, max_members)
                    const existingClusterIndex = dynamicClusters.findIndex(c => c.id === clusterId);
                    if (existingClusterIndex > -1) {
                         // Update the existing cluster object with dynamic status info from the server
                         dynamicClusters[existingClusterIndex].current_members = cluster.current_members || 0;
                         dynamicClusters[existingClusterIndex].cohort_id = cluster.cohort_id;
                         // The dynamic_clusters array still holds static info like name/details
                    } else {
                         // If a new cluster appeared, add it.
                         dynamicClusters.push(cluster);
                    }
                    
                    // Update caches for quick access in rendering (contains all status flags)
                    clusterStatusCache[clusterId] = {
                        cohort_id: cluster.cohort_id || `Cluster_${clusterId}`, 
                        is_full: cluster.is_full || false, 
                        current_members: cluster.current_members || 0,
                        vcf_uploaded: cluster.vcf_uploaded || false, 
                        vcf_file_name: cluster.vcf_file_name || null, 
                        vcf_download_count: cluster.vcf_download_count || 0, 
                        max_members: cluster.max_members || MAX_COHORT_SIZE, 
                        user_has_downloaded: cluster.user_has_downloaded || false, // User Requirement 2
                    };
                    
                    if (cluster.user_is_member) {
                        userClusterMemberships[clusterId] = { ...clusterStatusCache[clusterId], user_is_member: true };
                    }
                });
                
                // Clear referral session data if fetching succeeds (meaning we processed the ref code)
                sessionStorage.removeItem('referral_ref_code');
                sessionStorage.removeItem('referral_cluster_id');
                highlightedClusterId = null; 

                renderClusters();
                console.log(`Successfully fetched and processed ${clusterData.length} cluster statuses.`);

            } catch (error) {
                console.error('Error fetching cluster data:', error);
                showNotification(`Failed to load cluster data: ${error.message}`, 'error');
                renderClusters(); 
            }
        }

        async function fetchUserProfile(currentUserId) {
            // MOCK implementation: Replace with real user profile fetch logic
            const hash = currentUserId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            
            let determinedCountry;
            if (hash % 3 === 0) {
                determinedCountry = 'Canada';
            } else if (hash % 3 === 1) {
                determinedCountry = 'Germany';
            } else {
                determinedCountry = 'South Africa';
            }
            
            userCountry = determinedCountry; 
            userReferralCode = currentUserId.substring(0, 8).toUpperCase();
            
            console.log(`MOCK User Profile Loaded: Country: ${userCountry}, Ref Code: ${userReferralCode}`);
        }

        async function handleFormSubmission(event) {
            event.preventDefault();

            if (!userId) {
                redirectToLogin();
                closeModal('inputModal');
                return;
            }

            const clusterId = document.getElementById('modalClusterId').value;
            const displayProfession = document.getElementById('displayProfession').checked; 
            
            // The refCode is now pulled inside fetchAndRenderClusters, but we keep the session store 
            // for the join logic in case the fetch fails before join.
            const refCode = sessionStorage.getItem('referral_ref_code');
            
            const cluster = dynamicClusters.find(c => c.id === parseInt(clusterId));
            const maxMembers = cluster?.max_members || MAX_COHORT_SIZE; 

            const joinData = {
                p_cluster_id: parseInt(clusterId),
                p_display_profession: displayProfession,
                p_user_id: userId,
                p_ref_code: refCode,
            };
            
            closeModal('inputModal');
            showNotification(`Attempting to join cluster ${clusterId}...`, 'info');
            
            document.querySelectorAll('.card button').forEach(btn => btn.disabled = true);

            try {
                const response = await fetch('/api/join-cluster', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(joinData)
                });

                const result = await response.json(); 
                
                if (!response.ok || !result.success) {
                    const errorMessage = result.message || 'Server error during cluster join.';
                    console.error(`API Call Failed: ${errorMessage}`);
                    showNotification(errorMessage, 'error');
                    
                    // Fetch to re-render all buttons and restore state
                    await fetchAndRenderClusters(); 
                    return;
                }
                
                // We rely on fetchAndRenderClusters to update caches and clear session storage on successful join.
                await fetchAndRenderClusters(); 

                const { cohort_id, is_full, current_members } = result;
                const remaining = maxMembers - current_members;
                
                if (is_full) {
                    showNotification(`Success! Cohort ${cohort_id} is now FULL. Checking VCF status...`, 'success');
                } else {
                    showNotification(`Successfully joined ${cohort_id}! Waiting for ${remaining.toLocaleString()} more members.`, 'success');
                }

            } catch (error) {
                console.error('Error joining cluster (Network/Parse error).', error);
                showNotification('An internal error occurred. Check console for details.', 'error');
            } finally {
                 // Fetch to re-enable buttons and ensure state is fresh
                 await fetchAndRenderClusters(); 
            }
        }

        /**
         * Initiates the download of the VCF file and increments the download count on the server.
         */
        async function downloadContacts(fileName, clusterId) { 
            if (!userId) {
                redirectToLogin();
                return;
            }

            const downloadButton = document.getElementById(`downloadBtn_${clusterId}`);
            if (downloadButton) {
                downloadButton.disabled = true;
                downloadButton.textContent = 'Starting Download...';
            }
            
            showNotification(`Requesting contact file: ${fileName}...`, 'info');

            try {
                // 1. Initiate Download of the VCF file
                const response = await fetch(`/api/download-contacts?file_name=${fileName}&cluster_id=${clusterId}&user_id=${userId}`, {
                    method: 'GET',
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    try {
                        const errorJson = JSON.parse(errorText);
                        throw new Error(errorJson.message || 'Server error during contact file retrieval.');
                    } catch {
                         throw new Error(errorText || 'Failed to retrieve file. It may not be fully generated yet.');
                    }
                }

                const contentType = response.headers.get("Content-Type");

                if (contentType && contentType.includes('text/vcard')) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = fileName; 
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    showNotification('Download started successfully! Tracking download...', 'success');
                    
                    // 2. Track the Download Action
                    try {
                         const trackResponse = await fetch('/api/track-download', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ cluster_id: clusterId, user_id: userId })
                         });

                         const trackResult = await trackResponse.json();

                         if (!trackResponse.ok || !trackResult.success) {
                              const errorMsg = trackResult.message || 'Download tracking failed on server.';
                              console.error('Download Tracking Failed:', errorMsg);
                              showNotification(`Warning: Download was successful, but tracking failed: ${errorMsg}`, 'error');
                         }
                        
                        // 3. Update the global state and re-render the card for instant feedback
                        // Regardless of tracking success/failure, the user has downloaded the file, so update the state.
                        
                        // Update local cache to reflect the new state immediately
                        if (clusterStatusCache[clusterId]) {
                            clusterStatusCache[clusterId].user_has_downloaded = true;
                            // Use server's new count or default to increment
                            const newCount = trackResult.new_download_count || clusterStatusCache[clusterId].vcf_download_count + 1;
                            clusterStatusCache[clusterId].vcf_download_count = newCount;
                            
                            if (userClusterMemberships[clusterId]) {
                                userClusterMemberships[clusterId].user_has_downloaded = true;
                                userClusterMemberships[clusterId].vcf_download_count = newCount;
                            }
                        }
                        
                        // Re-render only the affected card or call renderClusters for simplicity
                        renderClusters();
                        showNotification('Download successfully tracked! Status updated.', 'success');


                    } catch (trackError) {
                        console.error('Error during download tracking POST request:', trackError);
                        showNotification('Warning: Download was successful, but tracking failed. Updating status.', 'error');
                        // Even on network error for tracking, update local state and re-render
                         if (clusterStatusCache[clusterId]) {
                            clusterStatusCache[clusterId].user_has_downloaded = true;
                            if (userClusterMemberships[clusterId]) {
                                userClusterMemberships[clusterId].user_has_downloaded = true;
                            }
                        }
                        renderClusters();
                    }

                } else {
                    throw new Error('The server did not return a valid VCF file format (expected text/vcard).');
                }

            } catch (error) {
                console.error('Download failed.', error);
                showNotification(error.message || 'Download failed. The file may not be fully generated yet.', 'error');
                if (downloadButton) {
                    // Re-render to ensure the button is restored correctly
                    renderClusters();
                }
            }
        }
        
        function handleReferralParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const clusterIdFromUrl = urlParams.get('cluster_id');
            const refCodeFromUrl = urlParams.get('ref_code');

            if (clusterIdFromUrl && refCodeFromUrl) {
                sessionStorage.setItem('referral_cluster_id', clusterIdFromUrl);
                sessionStorage.setItem('referral_ref_code', refCodeFromUrl);
                console.log(`URL Referral Params captured and saved to session: Cluster ID ${clusterIdFromUrl}, Ref Code ${refCodeFromUrl.substring(0, 8)}...`);
            } else if (urlParams.get('cluster_id') || urlParams.get('ref_code')) {
                console.warn("Incomplete referral link detected in URL. Skipping session storage of incomplete link.");
            }
            
            const storedClusterId = sessionStorage.getItem('referral_cluster_id');
            
            if (storedClusterId) {
                highlightedClusterId = parseInt(storedClusterId);
                console.log(`Setting highlighted cluster ID from session storage: ${highlightedClusterId}`);
            }
        }

        // --- 5. SUPABASE INITIALIZATION (Client-side Silent Auth) ---
        async function initializeSupabase() {
            console.log("Supabase initialization sequence started.");
            
            if (!window.supabase || !window.supabase.createClient) {
                 console.error("FATAL: Supabase library not found on global window object.");
                 isAuthReady = true;
                 renderClusters(); 
                 return;
            }
            
            try {
                supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
                
                // Fetch static cluster definitions first
                await fetchClustersFromSupabase(); 

                const { data: { session }, error } = await supabase.auth.getSession();
                
                if (error) {
                    throw error;
                }

                if (session && session.user) {
                    userId = session.user.id;
                    console.log(`User Authenticated. ID: ${userId.substring(0, 8)}...`); 
                    
                    await fetchUserProfile(userId);

                } else {
                    console.log("No active session found. Running as Guest.");
                }

            } catch (error) {
                console.error("Supabase Initialization Failed (Fatal).", error);
                showNotification("App failed to initialize. See console for details.", 'error');
                
            } finally {
                isAuthReady = true; 
                
                // ** UPDATED LOGIC (User Requirement 3) **
                // Always call the unified fetcher now, regardless of login state.
                await fetchAndRenderClusters(); 
            }
        }

        // --- 6. INITIALIZATION ---

        handleReferralParams();

        // Expose required functions to the global scope for onclick handlers
        window.redirectToLogin = redirectToLogin; 
        window.downloadContacts = downloadContacts;
        window.showModal = showModal;
        window.closeModal = closeModal;
        window.generateShareLink = generateShareLink; 
        window.viewClusterStats = viewClusterStats;
        
        document.getElementById('contactForm').addEventListener('submit', handleFormSubmission);
        
        initializeSupabase();

    </script>
</body>
</html>