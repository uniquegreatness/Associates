<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interest Cluster Contact Exchange</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Define the primary color palette based on a bright blue */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap');
        :root {
            --primary-blue: #3b82f6; /* Tailwind blue-500 */
            --light-blue: #eff6ff; /* Tailwind blue-50 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-blue);
            color: #1f2937; /* Dark text for high contrast */
        }
        .card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px rgba(59, 130, 246, 0.15);
        }
        /* Style for highlighted referral card */
        .card-highlight {
            border: 2px solid #f59e0b; /* Amber/Yellow border */
            transform: scale(1.02);
            box-shadow: 0 10px 25px rgba(245, 158, 11, 0.3);
        }
        .join-btn {
            background-color: var(--primary-blue);
            transition: background-color 0.2s ease;
        }
        .join-btn:hover {
            background-color: #2563eb; /* Tailwind blue-600 */
        }
        .full-btn {
            background-color: #6b7280; /* Tailwind gray-500 */
            cursor: not-allowed;
            opacity: 0.8;
        }
        .login-prompt-btn {
            background-color: #f59e0b; /* Tailwind amber-500 */
            transition: background-color 0.2s ease;
        }
        .login-prompt-btn:hover {
             background-color: #d97706; /* Tailwind amber-600 */
        }
        /* Ensure the clamp works for card descriptions */
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;  
            overflow: hidden;
        }
        .download-btn {
            background-color: #10b981; /* Tailwind emerald-500 */
            transition: background-color 0.2s ease;
        }
        .download-btn:hover {
            background-color: #059669; /* Tailwind emerald-600 */
        }
        
        /* --- NEW STYLES FOR REDUCED BUTTONS AND STATS --- */
        .member-actions-full {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        .connection-stats-text {
            /* Maximize space for the text */
            flex-grow: 1;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            font-weight: 600; /* semi-bold */
            color: #1f2937; /* text-gray-800 */
        }
        .action-icon-btn {
            /* Icon-only button styles */
            width: 40px; /* Fixed size */
            height: 40px;
            padding: 0;
            border-radius: 9999px; /* Fully rounded */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevents text from shrinking the button */
            transition: background-color 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .share-btn-icon { background-color: #f59e0b; color: white; }
        .share-btn-icon:hover { background-color: #d97706; }
        .stats-btn-icon { background-color: #3b82f6; color: white; }
        .stats-btn-icon:hover { background-color: #2563eb; }
        
        /* New style for downloaded state button */
        .downloaded-btn {
            background-color: #9ca3af; /* Tailwind gray-400 */
            cursor: not-allowed;
            color: #ffffff;
            font-weight: 600;
        }
        /* --- END NEW STYLES --- */
        
        /* Styling for the popularity tags in the stats modal */
        .popularity-tag {
            padding: 2px 6px;
            border-radius: 9999px; /* Full rounded corners */
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 8px;
        }
        .pop-most { background-color: #d1fae5; color: #065f46; } /* Green */
        .pop-avg { background-color: #fef3c7; color: #b45309; } /* Amber */
        .pop-less { background-color: #fee2e2; color: #991b1b; } /* Red */

        /* --- NEW STYLES FOR BLINKING DOWNLOAD BUTTON --- */
        @keyframes blink-highlight {
            0%, 100% { 
                background-color: #f59e0b; /* Amber 500 */
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); /* Subtle glow start */
            }
            50% { 
                background-color: #ef4444; /* Red 500 */
                box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); /* Glow expands and fades */
            }
        }
        .download-vcf-urgent {
            animation: blink-highlight 1.5s infinite;
            border: 2px solid #f59e0b; /* Initial highlight border */
            color: white !important;
        }
        /* --- END BLINKING STYLES --- */
    </style>
</head>
<body class="min-h-screen pb-4">

    <div id="notificationArea" class="fixed top-4 right-4 z-50 w-full max-w-xs space-y-2">
        </div>

    <header class="bg-white shadow-lg sticky top-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <h1 class="text-2xl font-bold text-blue-600">NEAR Network</h1>
                <nav>
                    </nav>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8">
        <h2 class="text-4xl font-extrabold text-gray-900 mb-4 text-center">
            Find Your Cohort
        </h2>
        <p class="text-center text-lg text-gray-500 mb-10 max-w-3xl mx-auto">
            Join a cluster and connect mutually with 5 others who share your interests. Your contact details will only be exchanged once the cohort is full.
        </p>
        
        <div id="clusterGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
            <div id="loadingClusters" class="col-span-full text-center py-12 text-gray-500">
                <i data-lucide="loader" class="w-8 h-8 mx-auto animate-spin text-blue-500"></i>
                <p class="mt-3 text-lg font-medium">Loading Interest Clusters...</p>
            </div>
            </div>
    </main>
    
    <div id="inputModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6 space-y-6">
            <h3 class="text-2xl font-bold text-gray-800 border-b pb-3">Final Step: Define Your VCF Display</h3>
            
            <form id="contactForm">
                <input type="hidden" id="modalClusterId">
                
                <p class="text-sm text-gray-500 mb-4">
                    Your profile data (Nickname, Profession, WhatsApp) will be fetched from the **`user_profiles`** table by the server. Please confirm how your name should appear in the shared contact file:
                </p>

                <div class="flex items-start p-4 border rounded-lg bg-blue-50">
                    <div class="flex items-center h-5">
                        <input id="displayProfession" type="checkbox" checked class="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded">
                    </div>
                    <div class="ml-3 text-sm">
                        <label for="displayProfession" class="font-bold text-gray-800">Display my Profession</label>
                        <p class="text-gray-600 mt-1">
                            <span class="font-semibold">Checked:</span> Name will be **[Nickname (Profession)]**.<br>
                            <span class="font-semibold">Unchecked:</span> Name will be **[Nickname NEARR]** (Note the space).
                        </p>
                    </div>
                </div>

                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" onclick="closeModal('inputModal')" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200">
                        Cancel
                    </button>
                    <button type="submit" class="join-btn px-4 py-2 text-sm font-medium text-white rounded-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                        Confirm Join Cluster
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="statsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="p-6 border-b flex justify-between items-center">
                <h3 class="text-2xl font-bold text-gray-800" id="statsModalTitle">Cluster Statistics: Loading...</h3>
                <button type="button" onclick="closeModal('statsModal')" class="text-gray-400 hover:text-gray-600">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <div class="p-6 overflow-y-auto flex-grow">
                <div id="statsModalContent" class="space-y-8">
                    
                    <div id="statsSummary" class="bg-gray-50 p-4 rounded-xl shadow-inner">
                        <h4 class="font-bold text-lg mb-4 text-blue-600">Demographic Overview</h4>
                        <div id="statsPlaceholder" class="text-gray-500 text-center py-4">
                            Loading statistical data...
                        </div>
                        
                        <div id="statsGrid" class="grid grid-cols-1 sm:grid-cols-2 gap-x-8 gap-y-4 text-sm hidden">
                            <div class="space-y-2">
                                <p><span class="font-semibold text-gray-700">Age Range:</span> <span id="stat_age">N/A</span></p>
                                <p><span class="font-semibold text-gray-700">Gender Breakdown:</span></p>
                                <ul id="stat_gender" class="ml-4 list-disc text-gray-600">
                                    </ul>
                                <p><span class="font-semibold text-gray-700">Geographic Mix:</span></p>
                                <ul id="stat_country" class="ml-4 list-disc text-gray-600">
                                    </ul>
                            </div>
                            
                            <div>
                                <p class="font-semibold text-gray-700 mb-2">Profession Mix (Top 5):</p>
                                <ul id="stat_profession" class="space-y-1">
                                    </ul>
                            </div>
                        </div>
                        
                    </div>
                    
                    <div>
                        <h4 class="font-bold text-lg mb-2 text-gray-800">Current Members (<span id="memberCount">0</span>/<span id="maxCount">5</span>)</h4>
                        <div class="overflow-x-auto rounded-xl border border-gray-200">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nickname</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Gender</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Age</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Country</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Looking For</th>
                                        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Available For</th>
                                    </tr>
                                </thead>
                                <tbody id="memberTableBody" class="bg-white divide-y divide-gray-200">
                                    </tbody>
                            </table>
                        </div>
                        <p id="memberLoading" class="text-center text-sm text-gray-500 mt-4">Loading member list...</p>
                    </div>
                </div>
            </div>
            
            <div class="p-4 border-t flex justify-end">
                <button type="button" onclick="closeModal('statsModal')" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200">
                    Close
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // --- 1. CONFIGURATION AND DATA ---

        // Global variables provided by the environment (required for Supabase integration)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // These keys are expected to be injected by the hosting environment
        const supabaseUrl = '__SUPABASE_URL_INJECTION__';
        const supabaseAnonKey = '__SUPABASE_ANON_KEY_INJECTION__';

        let supabase; // Global instance for the client
        let userId = null;
        let userReferralCode = null;
        let isAuthReady = false; // Tracks if the initial Supabase session check is complete

        // Viewer's Country - Set to a placeholder. It will be determined dynamically upon successful authentication.
        let userCountry = "Loading Country..."; 
        
        // ** DYNAMIC CLUSTER DATA **
        // Global array to hold clusters fetched from Supabase
        let dynamicClusters = []; 
        
        // The Fixed Capacity Cohort Size (Used as a fallback default if max_members is not available)
        const MAX_COHORT_SIZE = 5;
        
        // ** STATE TRACKING **
        // Tracks user's membership status for quick access: { cluster_id: { ..., user_is_member: true } }
        let userClusterMemberships = {}; 
        // Tracks the overall cohort status: { cluster_id: { cohort_id: 'C_1_2', is_full: false, current_members: 3, vcf_uploaded: false, vcf_file_name: null, vcf_download_count: 0, max_members: 5, user_has_downloaded: false, spots_left: 2 } }
        let clusterStatusCache = {}; 
        
        // ** REFERRAL STATE TRACKING **
        let highlightedClusterId = null; // Cluster ID from referral link, used for UI highlight


        /**
         * Fetches all clusters from the dynamic_clusters Supabase table.
         * Populates the global dynamicClusters array.
         */
        async function fetchClustersFromSupabase() {
            try {
                if (!supabase) throw new Error("Supabase client is not initialized.");
                
                // Fetch necessary fields from dynamic_clusters
                const { data, error } = await supabase
                    .from('dynamic_clusters')
                    .select('id, name, details, max_members, referral_message_template')
                    .order('id', { ascending: true }); 

                if (error) {
                    console.error('Supabase Error fetching dynamic clusters:', error);
                    showNotification(`Error loading clusters: ${error.message}`, 'error');
                    dynamicClusters = []; 
                } else {
                    dynamicClusters = data;
                    console.log(`Successfully loaded ${dynamicClusters.length} clusters from Supabase.`);
                }

            } catch (err) {
                console.error('Fatal Error in fetchClustersFromSupabase:', err);
                dynamicClusters = []; 
                showNotification('Fatal error during initial cluster fetch.', 'error');
            }
        }


        /**
         * Fetches the customized message template from the already loaded dynamicClusters array.
         * @param {number} clusterId - The ID of the cluster.
         * @returns {Promise<string>} - The message template containing the {{referral_link}} placeholder.
         */
        async function fetchClusterReferralMessage(clusterId) {
            try {
                const cluster = dynamicClusters.find(c => c.id === clusterId);
                
                if (!cluster) {
                     console.warn(`Cluster ID ${clusterId} not found in loaded data.`);
                     return "Join this unique interest cohort I'm in on NEAR Network! Get your unique link here: {{referral_link}}";
                }
                
                let rawTemplate = cluster.referral_message_template || "Join this unique interest cohort I'm in on NEAR Network! Get your unique link here: {{referral_link}}";
                const clusterName = cluster.name || 'a unique interest';
                
                if (rawTemplate.includes('[Cluster Name]')) {
                    rawTemplate = rawTemplate.replace('[Cluster Name]', clusterName);
                }
                
                return rawTemplate;

            } catch (err) {
                console.error('Fatal Error in fetchClusterReferralMessage:', err);
                return "Hey, check out this great cluster on NEAR Network! Get your unique link here: {{referral_link}}";
            }
        }
        
        // --- 2. UI MANIPULATION AND HELPERS ---

        function redirectToLogin() {
            sessionStorage.setItem('intended_destination', window.location.pathname + window.location.search);
            console.log(`Saved intended destination to: ${sessionStorage.getItem('intended_destination')}`);

            showNotification("You must be logged in to join or download contacts. Redirecting to login...", 'info');
            
            setTimeout(() => {
                window.location.href = '/login.html';
            }, 1500);
        }

        function showNotification(message, type) {
            const area = document.getElementById('notificationArea');
            const colorMap = {
                'success': { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-400' },
                'error': { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-400' },
                'info': { bg: 'bg-blue-100', text: 'text-blue-800', border: 'border-blue-400' },
            };
            const colors = colorMap[type] || colorMap['info'];

            const notification = document.createElement('div');
            notification.className = `${colors.bg} ${colors.text} p-4 rounded-lg border-l-4 ${colors.border} shadow-lg transition-opacity duration-300`;
            notification.textContent = message;

            area.prepend(notification);
            
            if (type === 'error') {
                console.error(`UI Notification (Error): ${message}`);
            } else if (type === 'info') {
                 console.warn(`UI Notification (Info): ${message}`);
            } else {
                 console.log(`UI Notification (Success): ${message}`);
            }

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.addEventListener('transitionend', () => notification.remove());
            }, 5000);
        }

        function openModal(modalId, clusterId = null) {
            if (!userId) {
                redirectToLogin();
                return;
            }
            if (clusterId && document.getElementById('modalClusterId')) {
                document.getElementById('modalClusterId').value = clusterId;
            }
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
            }
        }
        
        function showModal(clusterId) {
             openModal('inputModal', clusterId);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('flex');
                modal.classList.add('hidden');
                if (modalId === 'inputModal') {
                    document.getElementById('contactForm').reset();
                }
            }
        }
        
        async function generateShareLink(clusterId) {
            if (!userId) {
                redirectToLogin();
                return;
            }
            
            if (!userReferralCode) {
                 showNotification("Cannot share: Your referral code is not available yet.", 'error');
                 return;
            }

            showNotification('Generating customized share link...', 'info');

            try {
                let messageTemplate = await fetchClusterReferralMessage(clusterId);
                const baseUrl = window.location.origin;
                const shareUrl = `${baseUrl}${window.location.pathname}?cluster_id=${clusterId}&ref_code=${userReferralCode}`;
                const finalShareText = messageTemplate.replace('{{referral_link}}', shareUrl);
                
                const tempInput = document.createElement('textarea');
                tempInput.value = finalShareText;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                
                showNotification('Customized share message and link copied to clipboard!', 'success');
                console.log(`Generated and copied text:\n\n${finalShareText}`);

            } catch (err) {
                console.error('Failed to generate or copy share text: ', err);
                showNotification('Failed to copy link. Please check console.', 'error');
            }
        }

        // --- 3. STATISTICAL UTILITY FUNCTIONS (Client-side aggregation) ---

        function calculateGenderDistribution(members) {
            // ... (keep original implementation)
            const total = members.length;
            if (total === 0) return { male_pct: 0, female_pct: 0, other_pct: 0 };

            let maleCount = 0;
            let femaleCount = 0;
            
            members.forEach(member => {
                const gender = member.gender ? String(member.gender).toLowerCase() : '';
                if (gender === 'male') {
                    maleCount++;
                } else if (gender === 'female') {
                    femaleCount++;
                }
            });

            const male_pct = ((maleCount / total) * 100).toFixed(0);
            const female_pct = ((femaleCount / total) * 100).toFixed(0);
            const otherCount = total - maleCount - femaleCount;
            const other_pct = ((otherCount / total) * 100).toFixed(0);

            return { male_pct, female_pct, other_pct };
        }

        function calculateAgeRange(members) {
            // ... (keep original implementation)
            if (members.length === 0) return 'N/A';

            const ages = members
                .map(m => parseInt(m.age, 10))
                .filter(age => !isNaN(age) && age > 0);

            if (ages.length === 0) return 'N/A';

            const minAge = Math.min(...ages);
            const maxAge = Math.max(...ages);

            if (minAge === maxAge) return `${minAge} years old`;
            return `${minAge} - ${maxAge} years`;
        }

        function calculateProfessionMix(members) {
            // ... (keep original implementation)
            const total = members.length;
            if (total === 0) return [];

            const professionCounts = {};
            members.forEach(member => {
                const profession = member.profession ? String(member.profession).trim() : 'Unspecified';
                professionCounts[profession] = (professionCounts[profession] || 0) + 1;
            });

            const professionList = Object.entries(professionCounts).map(([name, count]) => ({
                name: name,
                count: count,
                pct: ((count / total) * 100).toFixed(0) 
            }));

            return professionList
                .sort((a, b) => b.count - a.count)
                .slice(0, 5);
        }

        function processAndRenderStats(stats, cohortMembers) {
            // ... (keep original implementation)
            const memberCount = cohortMembers.length;
            const ageSpan = document.getElementById('stat_age');
            const genderList = document.getElementById('stat_gender');
            const countryList = document.getElementById('stat_country');
            const professionList = document.getElementById('stat_profession');
            const statsGrid = document.getElementById('statsGrid');
            
            genderList.innerHTML = '';
            countryList.innerHTML = '';
            professionList.innerHTML = '';
            
            ageSpan.textContent = calculateAgeRange(cohortMembers);
            
            const genderDistribution = calculateGenderDistribution(cohortMembers);
            
            if (genderDistribution.male_pct > 0) {
                genderList.insertAdjacentHTML('beforeend', `<li>Male: ${genderDistribution.male_pct}%</li>`);
            }
            if (genderDistribution.female_pct > 0) {
                genderList.insertAdjacentHTML('beforeend', `<li>Female: ${genderDistribution.female_pct}%</li>`);
            }
            if (genderDistribution.other_pct > 0) {
                genderList.insertAdjacentHTML('beforeend', `<li>Other / N/A: ${genderDistribution.other_pct}%</li>`);
            }
            if (memberCount === 0 || (genderDistribution.male_pct === 0 && genderDistribution.female_pct === 0 && genderDistribution.other_pct === 0)) {
                genderList.insertAdjacentHTML('beforeend', `<li>No gender data available.</li>`);
            }

            let viewerCountryCount = 0;
            cohortMembers.forEach(member => {
                const country = member.country ? String(member.country).trim() : '';
                if (country.toLowerCase() === userCountry.toLowerCase()) {
                    viewerCountryCount++;
                }
            });
            let totalOthersCount = memberCount - viewerCountryCount; 
            
            const viewerCountryPct = memberCount > 0 ? ((viewerCountryCount / memberCount) * 100).toFixed(0) : 0;
            const abroadPct = memberCount > 0 ? ((totalOthersCount / memberCount) * 100).toFixed(0) : 0;

            countryList.insertAdjacentHTML('beforeend', `<li>${userCountry}: ${viewerCountryPct}%</li>`);
            countryList.insertAdjacentHTML('beforeend', `<li>Abroad: ${abroadPct}%</li>`);

            const topProfessions = calculateProfessionMix(cohortMembers);
            
            if (topProfessions.length > 0) {
                topProfessions.forEach((p, index) => {
                    let popClass = '';
                    let popularityText = '';
                    if (index < 2) { 
                        popClass = 'pop-most';
                        popularityText = 'Top Mix';
                    } else if (index === 2) {
                         popClass = 'pop-avg';
                         popularityText = 'Mid Mix';
                    } else {
                        popClass = 'pop-less';
                        popularityText = 'Lower Mix';
                    }
                    
                    const li = `
                        <li class="flex items-center">
                            <span class="text-gray-900 font-medium">${p.name} (${p.pct}%)</span>
                            <span class="popularity-tag ${popClass}">${popularityText}</span>
                        </li>
                    `;
                    professionList.insertAdjacentHTML('beforeend', li);
                });
            } else {
                 professionList.insertAdjacentHTML('beforeend', `<li class="text-gray-500">No profession data available.</li>`);
            }

            document.getElementById('statsPlaceholder').classList.add('hidden');
            statsGrid.classList.remove('hidden');
        }

        /**
         * FIX IMPLEMENTED HERE:
         * 1. The clusterId is explicitly parsed to an integer to match the type in dynamicClusters.
         * 2. Added debugging logs for easier future troubleshooting if the cluster lookup fails.
         */
        async function viewClusterStats(clusterId, clusterName) {
            if (!userId) {
                redirectToLogin();
                return;
            }
            
            // CRITICAL FIX 1: Parse the string ID from the HTML onclick to an integer for strict comparison
            const targetClusterId = parseInt(clusterId, 10);
            
            if (isNaN(targetClusterId)) {
                console.error(`[Stats Error] Invalid Cluster ID received: ${clusterId}`);
                showNotification("Invalid cluster selected. Cannot load stats.", 'error');
                return;
            }

            // CRITICAL FIX 2: Lookup cluster in local data using the parsed ID
            const cluster = dynamicClusters.find(c => c.id === targetClusterId);
            
            // This is the check that currently fails, triggering the reported error message.
            if (!cluster) {
                console.error(`[Stats Error] Cluster ID ${targetClusterId} not found in local dynamicClusters array.`);
                console.log("Available IDs in local cache:", dynamicClusters.map(c => c.id));
                const message = "Could not load statistic for testing. No active cohort found. (Local data mismatch)";
                showNotification(message, 'error');
                return;
            }

            const clusterMaxMembers = cluster?.max_members || MAX_COHORT_SIZE; 

            document.getElementById('statsModalTitle').textContent = `Cluster Statistics: ${clusterName}`;
            document.getElementById('statsPlaceholder').classList.remove('hidden');
            document.getElementById('statsGrid').classList.add('hidden');
            document.getElementById('memberTableBody').innerHTML = '';
            document.getElementById('memberLoading').textContent = 'Loading member list...';
            document.getElementById('memberLoading').classList.remove('hidden');
            document.getElementById('memberCount').textContent = '...';
            document.getElementById('maxCount').textContent = clusterMaxMembers; 
            
            openModal('statsModal');
            
            try {
                // Use targetClusterId (number) for the API call
                const response = await fetch(`/api/cluster-stats?cluster_id=${targetClusterId}&user_id=${userId}&user_country=${userCountry}`, {
                    method: 'GET',
                });
                
                const result = await response.json();

                if (!response.ok || !result.success) {
                     const errorMsg = result.message || "Failed to fetch cluster statistics.";
                     document.getElementById('statsPlaceholder').textContent = `Error: ${errorMsg}`;
                     document.getElementById('memberLoading').textContent = 'Error loading members.';
                     throw new Error(errorMsg);
                }

                const { cohort_members, cluster_stats } = result;

                const currentMemberCount = cohort_members.length;
                processAndRenderStats(cluster_stats, cohort_members); 
                
                const tableBody = document.getElementById('memberTableBody');
                tableBody.innerHTML = ''; 
                
                document.getElementById('memberCount').textContent = currentMemberCount;

                if (currentMemberCount === 0) {
                     document.getElementById('memberLoading').textContent = 'No other members have joined yet.';
                     document.getElementById('memberLoading').classList.remove('hidden');
                } else {
                    cohort_members.forEach(member => {
                        // The user's prompt mentions race/racial groups in the context of statistics,
                        // but the current data schema only includes gender, age, country, profession,
                        // friend_reasons, and services. We cannot display racial statistics without
                        // that data being present in the API response or profile schema.
                        
                        const lookingFor = (member.friend_reasons && Array.isArray(member.friend_reasons) ? member.friend_reasons.join(', ') : member.friend_reasons) || 'N/A';
                        const availableFor = (member.services && Array.isArray(member.services) ? member.services.join(', ') : member.services) || 'N/A';

                        const row = `
                            <tr class="hover:bg-gray-50">
                                <td class="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${member.nickname}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${member.gender || 'N/A'}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${member.age || 'N/A'}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${member.country || 'N/A'}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${lookingFor}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${availableFor}</td>
                            </tr>
                        `;
                        tableBody.insertAdjacentHTML('beforeend', row);
                    });
                    document.getElementById('memberLoading').classList.add('hidden');
                }

            } catch (error) {
                console.error('Error fetching cluster stats:', error);
                showNotification(`Could not load statistics for ${clusterName}.`, 'error');
            }
        }


        /**
         * Renders the cluster cards based on the current state.
         * GOAL 1: Implement user_has_downloaded logic.
         */
        function renderClusters() {
            try {
                console.log("Rendering cluster cards...");
                
                const grid = document.getElementById('clusterGrid');
                const loadingElement = document.getElementById('loadingClusters');

                if (!grid) {
                     console.error("CRITICAL: 'clusterGrid' element not found!");
                     showNotification("Fatal Error: Cannot find the card display area.", 'error');
                     return; 
                }

                grid.innerHTML = ''; 

                if (loadingElement) {
                     loadingElement.classList.add('hidden'); 
                }


                dynamicClusters.forEach(category => {
                    const clusterId = category.id;
                    const clusterName = category.name; 
                    
                    const maxMembers = category.max_members || MAX_COHORT_SIZE; 
                    
                    // Retrieve all NEW metrics from the cache
                    const state = clusterStatusCache[clusterId] || { 
                        cohort_id: `Cluster_${clusterId}`, 
                        is_full: false, 
                        current_members: 0,
                        vcf_uploaded: false, 
                        vcf_file_name: null, 
                        vcf_download_count: 0, 
                        max_members: maxMembers, 
                        user_has_downloaded: false, // NEW METRIC
                        spots_left: maxMembers, // Fallback for the new field
                    };
                    
                    const userIsMember = userClusterMemberships[clusterId]?.user_is_member; 
                    // CRITICAL FIX: Use the reliable spots_left from the cache (updated in checkAllClusterStatuses/handleFormSubmission)
                    const remaining = state.spots_left !== undefined ? state.spots_left : (state.max_members - state.current_members);
                    const isDownloadReady = state.is_full && state.vcf_uploaded && state.vcf_file_name;
                    
                    // NEW: Access the download property
                    const userHasDownloaded = state.user_has_downloaded;
                    
                    // NEW: Connection Stats Calculation
                    const downloadCount = state.vcf_download_count;
                    const leftToConnect = state.max_members - downloadCount;
                    // The text uses the total number of members (max_members) as the potential reach
                    const statsText = `You made ${downloadCount} connections, ${leftToConnect} left to connect with you.`;


                    let primaryButtonHTML = '';
                    let actionButtonsHTML = '';
                    let cardClass = "card bg-white p-6 rounded-xl space-y-4";
                    
                    // Add highlighting for referral links
                    if (highlightedClusterId && category.id === highlightedClusterId) {
                        cardClass += " card-highlight";
                        if (!userIsMember && userId) {
                            showNotification(`You were invited to the '${category.name}' cluster!`, 'info');
                        }
                    }

                    if (!isAuthReady) {
                        primaryButtonHTML = `<button class="bg-gray-400 cursor-not-allowed w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>Loading...</button>`;
                    } else if (!userId) {
                        // Guest User
                        primaryButtonHTML = `<button class="login-prompt-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" onclick="redirectToLogin()">Log in to Join</button>`;
                    } else if (userIsMember) {
                        // Authenticated Member (Show Action Buttons)
                        
                        if (userHasDownloaded) {
                             // GOAL: Downloaded State (x/y)
                            const x = state.vcf_download_count;
                            const y = state.max_members;
                            const downloadedText = `Downloaded (${x}/${y})`;

                            primaryButtonHTML = `<button class="downloaded-btn w-full font-semibold py-2 rounded-lg shadow-md" disabled>${downloadedText}</button>`;

                             // ACTION BUTTONS: Icon Buttons (Left) + Stats Text (Right) -- UPDATED LAYOUT
                             actionButtonsHTML = `
                                <div class="member-actions-full flex items-center justify-between mt-2">
                                    <div class="flex gap-2"> 
                                        <button class="action-icon-btn stats-btn-icon" title="Stats" onclick="viewClusterStats(${clusterId}, '${clusterName}')">
                                            <i data-lucide="bar-chart-2" class="w-4 h-4"></i>
                                        </button>
                                        <button class="action-icon-btn share-btn-icon" title="Share" onclick="generateShareLink(${clusterId})">
                                            <i data-lucide="share-2" class="w-4 h-4"></i>
                                        </button>
                                    </div>
                                    <p class="connection-stats-text text-gray-800 text-right">
                                        ${statsText}
                                    </p>
                                </div>
                            `;

                        } else if (isDownloadReady) {
                            // GOAL 1: Download VCF State (Cohort is full, VCF is ready, and user hasn't downloaded)
                            const fileNameToUse = state.vcf_file_name || state.cohort_id; 
                            
                            // NEW: Apply blinking class
                            const blinkingClass = ' download-vcf-urgent'; 
                            
                            // PRIMARY BUTTON: Download VCF (with blinking class)
                            primaryButtonHTML = `<button id="downloadBtn_${clusterId}" class="download-btn hover:bg-emerald-600 w-full text-white font-semibold py-2 rounded-lg shadow-md${blinkingClass}" onclick="downloadContacts('${fileNameToUse}', ${clusterId})">Download VCF</button>`;
                            
                            // ACTION BUTTONS: Icon Buttons (Left) + Stats Text (Right) -- UPDATED LAYOUT
                            actionButtonsHTML = `
                                <div class="member-actions-full flex items-center justify-between mt-2">
                                    <div class="flex gap-2"> 
                                        <button class="action-icon-btn stats-btn-icon" title="Stats" onclick="viewClusterStats(${clusterId}, '${clusterName}')">
                                            <i data-lucide="bar-chart-2" class="w-4 h-4"></i>
                                        </button>
                                        <button class="action-icon-btn share-btn-icon" title="Share" onclick="generateShareLink(${clusterId})">
                                            <i data-lucide="share-2" class="w-4 h-4"></i>
                                        </button>
                                    </div>
                                    <p class="connection-stats-text text-gray-800 text-right">
                                        ${statsText}
                                    </p>
                                </div>
                            `;

                        } else if (state.is_full && !isDownloadReady) {
                            // Cohort is full, but VCF is processing
                            primaryButtonHTML = `<button class="full-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>VCF Processing...</button>`;
                             // Still allow sharing/stats while waiting for VCF
                            actionButtonsHTML = `
                                <div class="member-actions-full flex justify-end">
                                    <button class="action-icon-btn stats-btn-icon" title="Stats" onclick="viewClusterStats(${clusterId}, '${clusterName}')">
                                        <i data-lucide="bar-chart-2" class="w-4 h-4"></i>
                                    </button>
                                    <button class="action-icon-btn share-btn-icon" title="Share" onclick="generateShareLink(${clusterId})">
                                        <i data-lucide="share-2" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            `;

                        } else {
                            // Cohort is still filling up (Open for new members)
                            primaryButtonHTML = `<button class="full-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>Joined! (${remaining} spots left)</button>`;
                            
                            // Show full-size action buttons here (no stats text)
                            actionButtonsHTML = `
                                <div class="member-actions-full flex justify-end gap-2 mt-3">
                                    <button class="action-btn stats-btn-icon px-3 py-2" title="View Stats" onclick="viewClusterStats(${clusterId}, '${clusterName}')">
                                        <i data-lucide="bar-chart-2" class="w-4 h-4"></i> Stats
                                    </button>
                                    <button class="action-btn share-btn-icon px-3 py-2" title="Share Link" onclick="generateShareLink(${clusterId})">
                                        <i data-lucide="share-2" class="w-4 h-4"></i> Share
                                    </button>
                                </div>
                            `;
                        }

                    } else if (state.is_full && !userIsMember) {
                        // Authenticated Non-member: Cohort Full
                        primaryButtonHTML = `<button class="full-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" disabled>Cluster Full (Wait for next)</button>`;
                    } else {
                        // Authenticated Non-member: Cohort Open
                        primaryButtonHTML = `<button class="join-btn w-full text-white font-semibold py-2 rounded-lg shadow-md" onclick="showModal(${clusterId})">Join Cluster</button>`;
                    }
                    
                    // Add a unique ID to the card div to make it easy to find for direct DOM manipulation in downloadContacts
                    const cardHTML = `
                        <div id="clusterCard_${clusterId}" class="${cardClass}" data-cluster-id="${clusterId}">
                            <h3 class="text-xl font-semibold text-blue-600">${category.name}</h3>
                            <p class="text-gray-500 text-sm h-16 line-clamp-3">
                                ${category.details}
                            </p>
                            ${primaryButtonHTML}
                            ${actionButtonsHTML}
                        </div>
                    `;
                    grid.insertAdjacentHTML('beforeend', cardHTML);
                });
                
                // Initialize Lucide icons after rendering cards
                lucide.createIcons();
                
                console.log("renderClusters finished.");

            } catch (error) {
                console.error("CRITICAL RENDER FAILURE:", error);
                showNotification(`Fatal rendering error: ${error.message}. Check console for details.`, 'error');
            }
        }
        
        // --- 4. CORE LOGIC (Node.js API Call Assumptions) ---

        async function fetchUserProfile(currentUserId) {
            // MOCK implementation: Replace with real user profile fetch logic
            const hash = currentUserId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            
            let determinedCountry;
            if (hash % 3 === 0) {
                determinedCountry = 'Canada';
            } else if (hash % 3 === 1) {
                determinedCountry = 'Germany';
            } else {
                determinedCountry = 'South Africa';
            }
            
            userCountry = determinedCountry; 
            userReferralCode = currentUserId.substring(0, 8).toUpperCase();
            
            console.log(`MOCK User Profile Loaded: Country: ${userCountry}, Ref Code: ${userReferralCode}`);
        }

        /**
         * Checks the current status for all clusters, now including download count and max members.
         */
        async function checkAllClusterStatuses() {
            if (!userId) {
                console.log("Skipping status check: User not logged in.");
                return;
            }
            
            showNotification('Checking cluster membership status...', 'info');

            const statusChecks = dynamicClusters.map(async (category) => {
                const clusterId = category.id;
                
                const MAX_RETRIES = 3;
                for (let i = 0; i < MAX_RETRIES; i++) {
                    try {
                        const response = await fetch(`/api/cohort-status?cluster_id=${clusterId}&user_id=${userId}`, {
                            method: 'GET',
                        });

                        const result = await response.json();

                        if (!response.ok || !result.success) {
                            throw new Error(result.message || 'Unknown status check error');
                        }
                        
                        // --- IMPORTANT: Update the global state caches with new metrics ---
                        clusterStatusCache[clusterId] = {
                            cohort_id: result.cohort_id,
                            is_full: result.is_full,
                            current_members: result.current_members,
                            vcf_uploaded: result.vcf_uploaded || false,
                            vcf_file_name: result.vcf_file_name || null,
                            vcf_download_count: result.vcf_download_count || 0,
                            max_members: result.max_members || category.max_members,
                            user_has_downloaded: result.user_has_downloaded || false, // NEW METRIC
                            spots_left: result.spots_left, // CRITICAL FIX: Save spots_left from server
                        };

                        if (result.user_is_member) {
                            userClusterMemberships[clusterId] = { ...clusterStatusCache[clusterId], user_is_member: true };
                        } else {
                             delete userClusterMemberships[clusterId];
                        }
                        return; // Success, exit retry loop

                    } catch (error) {
                        console.warn(`Status check failed for Cluster ${clusterId} (Attempt ${i + 1}/${MAX_RETRIES}):`, error.message);
                        if (i === MAX_RETRIES - 1) {
                            console.error(`Status check ultimately failed for Cluster ${clusterId}.`);
                            return;
                        }
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                    }
                }
            });

            await Promise.all(statusChecks);
            console.log("All cluster statuses checked. Rendering final state.");
            renderClusters(); // Render once all checks are complete
        }

        async function handleFormSubmission(event) {
            event.preventDefault();

            if (!userId) {
                redirectToLogin();
                closeModal('inputModal');
                return;
            }

            const clusterId = document.getElementById('modalClusterId').value;
            const displayProfession = document.getElementById('displayProfession').checked; 
            
            const refCode = sessionStorage.getItem('referral_ref_code');
            
            const cluster = dynamicClusters.find(c => c.id === parseInt(clusterId));
            const maxMembers = cluster?.max_members || MAX_COHORT_SIZE; 

            const joinData = {
                p_cluster_id: parseInt(clusterId),
                p_display_profession: displayProfession,
                p_user_id: userId,
                p_ref_code: refCode,
            };
            
            closeModal('inputModal');
            showNotification(`Attempting to join cluster ${clusterId}...`, 'info');
            
            document.querySelectorAll('.card button').forEach(btn => btn.disabled = true);

            try {
                const response = await fetch('/api/join-cluster', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(joinData)
                });

                const result = await response.json(); 
                
                if (!response.ok || !result.success) {
                    const errorMessage = result.message || 'Server error during cluster join.';
                    console.error(`API Call Failed: ${errorMessage}`);
                    showNotification(errorMessage, 'error');
                    
                    await checkAllClusterStatuses(); // Retain for error cleanup
                    return;
                }
                
                sessionStorage.removeItem('referral_ref_code');
                sessionStorage.removeItem('referral_cluster_id');
                highlightedClusterId = null; 

                const { cohort_id, is_full, current_members } = result;
                
                // Server response should now include vcf_download_count, max_members, and user_has_downloaded
                clusterStatusCache[clusterId] = {
                    cohort_id: cohort_id,
                    is_full: is_full,
                    current_members: current_members,
                    vcf_uploaded: result.vcf_uploaded || false,
                    vcf_file_name: result.vcf_file_name || null,
                    vcf_download_count: result.vcf_download_count || 0,
                    max_members: maxMembers,
                    user_has_downloaded: result.user_has_downloaded || false,
                    spots_left: result.spots_left, // CRITICAL FIX: Save spots_left from server
                };
                
                userClusterMemberships[clusterId] = { ...clusterStatusCache[clusterId], user_is_member: true };
                
                renderClusters();
                
                if (is_full) {
                    showNotification(`Success! Cohort ${cohort_id} is now FULL. Checking VCF status...`, 'success');
                    // Removed immediate status check to prevent race condition.
                } else {
                    const remaining = maxMembers - current_members;
                    showNotification(`Successfully joined ${cohort_id}! Waiting for ${remaining.toLocaleString()} more members.`, 'success');
                }

            } catch (error) {
                console.error('Error joining cluster (Network/Parse error).', error);
                showNotification('An internal error occurred. Check console for details.', 'error');
            } finally {
                // Removed redundant cluster status check to prevent race condition.
            }
        }

        /**
         * Initiates the download of the VCF file and increments the download count on the server.
         * GOAL 2: Implement download tracking logic.
         * @param {string} fileName - The full name of the VCF file in storage.
         * @param {number} clusterId - The ID of the cluster being downloaded.
         */
        async function downloadContacts(fileName, clusterId) { 
            if (!userId) {
                redirectToLogin();
                return;
            }

            const downloadButton = document.getElementById(`downloadBtn_${clusterId}`);
            if (downloadButton) {
                downloadButton.disabled = true;
                downloadButton.textContent = 'Starting Download...';
                // Remove blinking class immediately upon click
                downloadButton.classList.remove('download-vcf-urgent');
            }
            
            showNotification(`Requesting contact file: ${fileName}...`, 'info');

            try {
                // 1. Initiate Download of the VCF file
                // Pass clusterId and userId to the backend API to handle the download (The file blob is returned)
                const response = await fetch(`/api/download-contacts?file_name=${fileName}&cluster_id=${clusterId}&user_id=${userId}`, {
                    method: 'GET',
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    try {
                        const errorJson = JSON.parse(errorText);
                        throw new Error(errorJson.message || 'Server error during contact file retrieval.');
                    } catch {
                         throw new Error(errorText || 'Failed to retrieve file. It may not be fully generated yet.');
                    }
                }

                const contentType = response.headers.get("Content-Type");

                if (contentType && contentType.includes('text/vcard')) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = fileName; 
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    showNotification('Download started successfully! Tracking download...', 'success');
                    
                    // 2. Track the Download Action
                    try {
                         const trackResponse = await fetch('/api/track-download', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ cluster_id: clusterId, user_id: userId }) // GOAL 2: Request Body
                         });

                         const trackResult = await trackResponse.json();

                         if (!trackResponse.ok || !trackResult.success) {
                              const errorMsg = trackResult.message || 'Download tracking failed on server.';
                              console.error('Download Tracking Failed:', errorMsg);
                              showNotification(`Warning: Download was successful, but tracking failed: ${errorMsg}`, 'error');
                              
                              // Re-enable the button if tracking failed, allowing a retry, but keep the UI consistent
                              if (downloadButton) {
                                downloadButton.disabled = false;
                                downloadButton.textContent = 'Download VCF';
                                // Reapply blinking if tracking failed
                                downloadButton.classList.add('download-vcf-urgent');
                              }

                         } else {
                            // 3. Update DOM for Instant Feedback (GOAL 2: Direct DOM update)
                            const clusterCard = document.getElementById(`clusterCard_${clusterId}`);
                            if (clusterCard) {
                                const buttonContainer = clusterCard.querySelector('#downloadBtn_' + clusterId);
                                if (buttonContainer) {
                                    // The button element itself needs to be replaced/modified
                                    // NOTE: We don't need to manually update the outerHTML here
                                    // as the next line (checkAllClusterStatuses) will trigger renderClusters,
                                    // which handles the complete card re-rendering.
                                }
                            }
                             
                             // Update local cache to reflect the new state immediately
                             // Crucially, use the updated counts returned from the server if available
                             if (clusterStatusCache[clusterId]) {
                                clusterStatusCache[clusterId].user_has_downloaded = true;
                                if (trackResult.vcf_download_count !== undefined) {
                                    clusterStatusCache[clusterId].vcf_download_count = trackResult.vcf_download_count;
                                }
                                // Also update the one in userMemberships if it exists
                                if (userClusterMemberships[clusterId]) {
                                     userClusterMemberships[clusterId].user_has_downloaded = true;
                                     if (trackResult.vcf_download_count !== undefined) {
                                         userClusterMemberships[clusterId].vcf_download_count = trackResult.vcf_download_count;
                                     }
                                }
                             }
                             
                            showNotification('Download successfully tracked! Status updated.', 'success');
                            
                            // Re-render to update the action buttons and connection stats text cleanly
                            renderClusters(); 
                         }

                    } catch (trackError) {
                        console.error('Error during download tracking POST request:', trackError);
                        showNotification('Warning: Download was successful, but tracking failed.', 'error');
                        // Re-enable button on tracking failure (as per original logic for download failures)
                        if (downloadButton) {
                            downloadButton.disabled = false;
                            downloadButton.textContent = 'Download VCF';
                            // Reapply blinking if tracking failed
                            downloadButton.classList.add('download-vcf-urgent');
                        }
                    }

                } else {
                    throw new Error('The server did not return a valid VCF file format (expected text/vcard).');
                }

            } catch (error) {
                console.error('Download failed.', error);
                showNotification(error.message || 'Download failed. The file may not be fully generated yet.', 'error');
                if (downloadButton) {
                    downloadButton.disabled = false;
                    downloadButton.textContent = 'Download VCF';
                    // If download failed (not tracking), re-apply blinking
                    downloadButton.classList.add('download-vcf-urgent');
                }
            }
        }
        
        function handleReferralParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const clusterIdFromUrl = urlParams.get('cluster_id');
            const refCodeFromUrl = urlParams.get('ref_code');

            if (clusterIdFromUrl && refCodeFromUrl) {
                sessionStorage.setItem('referral_cluster_id', clusterIdFromUrl);
                sessionStorage.setItem('referral_ref_code', refCodeFromUrl);
                console.log(`URL Referral Params captured and saved to session: Cluster ID ${clusterIdFromUrl}, Ref Code ${refCodeFromUrl.substring(0, 8)}...`);
            } else if (urlParams.get('cluster_id') || urlParams.get('ref_code')) {
                console.warn("Incomplete referral link detected in URL. Skipping session storage of incomplete link.");
            }
            
            const storedClusterId = sessionStorage.getItem('referral_cluster_id');
            
            if (storedClusterId) {
                highlightedClusterId = parseInt(storedClusterId);
                console.log(`Setting highlighted cluster ID from session storage: ${highlightedClusterId}`);
            }
        }

        // --- 5. SUPABASE INITIALIZATION (Client-side Silent Auth) ---
        async function initializeSupabase() {
            console.log("Supabase initialization sequence started.");
            
            if (!window.supabase || !window.supabase.createClient) {
                 console.error("FATAL: Supabase library not found on global window object.");
                 isAuthReady = true;
                 renderClusters(); 
                 return;
            }

            // --- FIX: CRITICAL CONFIGURATION CHECK FOR SERVER INJECTION FAILURE ---
            if (supabaseUrl.includes('__SUPABASE_URL_INJECTION__') || supabaseAnonKey.includes('__SUPABASE_ANON_KEY_INJECTION__')) {
                const errorMessage = "FATAL ERROR: Supabase configuration placeholders were not replaced by the server. Check your server-side template serving logic (server.js and cohortUtils.js).";
                console.error(errorMessage, { supabaseUrl, supabaseAnonKey });
                showNotification("App failed to initialize: Missing Supabase config.", 'error');
                isAuthReady = true;
                renderClusters();
                return;
            }
            // --- END FIX ---
            
            try {
                supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
                
                await fetchClustersFromSupabase(); 

                const { data: { session }, error } = await supabase.auth.getSession();
                
                if (error) {
                    throw error;
                }

                if (session && session.user) {
                    userId = session.user.id;
                    console.log(`User Authenticated. ID: ${userId.substring(0, 8)}...`); 
                    
                    await fetchUserProfile(userId);

                } else {
                    console.log("No active session found. Running as Guest.");
                }

            } catch (error) {
                console.error("Supabase Initialization Failed (Fatal).", error);
                showNotification("App failed to initialize. See console for details.", 'error');
                
            } finally {
                isAuthReady = true; 
                
                if (userId) {
                    await checkAllClusterStatuses(); 
                } else {
                    renderClusters(); 
                }
            }
        }

        // --- 6. INITIALIZATION ---

        handleReferralParams();

        // Expose required functions to the global scope for onclick handlers
        window.redirectToLogin = redirectToLogin; 
        window.downloadContacts = downloadContacts;
        window.showModal = showModal;
        window.closeModal = closeModal;
        window.generateShareLink = generateShareLink; 
        window.viewClusterStats = viewClusterStats;
        
        document.getElementById('contactForm').addEventListener('submit', handleFormSubmission);
        
        initializeSupabase();

    </script>
</body>
</html>